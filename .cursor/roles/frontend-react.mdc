---
description: "React 18 + TypeScript + Vite + Tailwind CSS Frontend Development"
globs: client/src/**/*.tsx,client/src/**/*.ts,!client/src/**/*.test.ts
alwaysApply: false
---
# React 18 + TypeScript + Vite + Tailwind CSS Development

You are an expert in React 18, TypeScript, Vite, Tailwind CSS, and modern frontend architecture.

## Key Principles

- Write concise, technical TypeScript code with accurate React patterns
- Use functional and declarative programming; avoid classes
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Use TypeScript for all code; prefer interfaces over types
- Avoid enums; use maps or union types instead
- File structure: exported component, subcomponents, hooks, utilities, types

## React & TypeScript Patterns

### Functional Components with TypeScript

```typescript
// ✅ CORRECT - React 18 functional component with TypeScript
interface DatasetCardProps {
  id: string
  name: string
  description: string
  tableCount: number
  isStarred?: boolean
  onStar?: (id: string) => void
}

function DatasetCard({
  id,
  name,
  description,
  tableCount,
  isStarred = false,
  onStar,
}: DatasetCardProps) {
  const handleStarClick = () => {
    onStar?.(id)
  }

  return (
    <article className="rounded-lg border border-gray-200 p-4 hover:shadow-md transition-shadow">
      <div className="flex items-start justify-between">
        <div className="flex-1">
          <h3 className="text-lg font-semibold text-gray-900">{name}</h3>
          <p className="mt-1 text-sm text-gray-600">{description}</p>
        </div>
        <button
          onClick={handleStarClick}
          className={`ml-4 text-2xl transition-colors ${
            isStarred ? "text-yellow-400" : "text-gray-300 hover:text-yellow-400"
          }`}
          aria-label={isStarred ? "Unstar dataset" : "Star dataset"}
        >
          ★
        </button>
      </div>
      <div className="mt-3 text-sm text-gray-500">
        {tableCount} table{tableCount !== 1 ? "s" : ""}
      </div>
    </article>
  )
}

export { DatasetCard, type DatasetCardProps }
```

### Custom Hooks Pattern

```typescript
// hooks/useDatasets.ts
import { useState, useEffect } from "react"
import { apiClient } from "@/api/client"

interface Dataset {
  id: string
  name: string
  description: string
  tableCount: number
}

interface UseDatasetResult {
  datasets: Dataset[]
  isLoading: boolean
  error: Error | null
  refetch: () => Promise<void>
}

export function useDatasets(): UseDatasetResult {
  const [datasets, setDatasets] = useState<Dataset[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const fetchDatasets = async () => {
    try {
      setIsLoading(true)
      setError(null)
      const data = await apiClient.get<{ data: Dataset[] }>("/datasets")
      setDatasets(data.data)
    } catch (err) {
      setError(err instanceof Error ? err : new Error("Unknown error"))
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    fetchDatasets()
  }, [])

  return {
    datasets,
    isLoading,
    error,
    refetch: fetchDatasets,
  }
}

// Usage in component
function DatasetList() {
  const { datasets, isLoading, error, refetch } = useDatasets()

  if (isLoading) return <LoadingSpinner />
  if (error) return <ErrorAlert error={error} onRetry={refetch} />

  return (
    <div className="grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3">
      {datasets.map((dataset) => (
        <DatasetCard key={dataset.id} {...dataset} />
      ))}
    </div>
  )
}
```

## Project Structure

```
frontend/
├── src/
│   ├── components/             # Reusable components
│   │   ├── common/             # Header, Footer, Layout
│   │   │   ├── Header.tsx
│   │   │   ├── Footer.tsx
│   │   │   └── Sidebar.tsx
│   │   ├── datasets/           # Dataset-specific components
│   │   │   ├── DatasetCard.tsx
│   │   │   ├── DatasetList.tsx
│   │   │   └── DatasetDetail.tsx
│   │   ├── charts/             # Recharts-based visualizations
│   │   │   ├── RowCountChart.tsx
│   │   │   └── AccessTrendChart.tsx
│   │   └── ui/                 # Generic UI primitives
│   │       ├── Button.tsx
│   │       ├── Card.tsx
│   │       ├── Input.tsx
│   │       └── Modal.tsx
│   ├── pages/                  # Full-page components (if using routing)
│   │   ├── Home.tsx
│   │   ├── DatasetExplorer.tsx
│   │   └── NotFound.tsx
│   ├── hooks/                  # Custom React hooks
│   │   ├── useDatasets.ts
│   │   ├── useAuth.ts
│   │   └── useWindowSize.ts
│   ├── api/                    # API client & data fetching
│   │   ├── client.ts           # Axios/fetch configuration
│   │   ├── datasets.ts         # Dataset API endpoints
│   │   └── types.ts            # API response types
│   ├── types/                  # TypeScript types & interfaces
│   │   ├── index.ts            # Exported types
│   │   └── api.ts              # API response types
│   ├── utils/                  # Utility functions
│   │   ├── cn.ts               # Tailwind classname helper
│   │   ├── format.ts           # Formatting utilities
│   │   └── storage.ts          # Local storage helpers
│   ├── styles/                 # Global styles
│   │   ├── index.css           # Tailwind directives
│   │   └── variables.css       # CSS custom properties
│   ├── App.tsx                 # Root component
│   └── main.tsx                # Vite entry point
├── public/
│   └── favicon.svg
├── index.html                  # HTML template
├── vite.config.ts              # Vite configuration
├── tailwind.config.ts          # Tailwind configuration
├── tsconfig.json               # TypeScript configuration
├── eslint.config.js            # ESLint configuration
└── package.json
```

## Component Patterns

### UI Button Component

```typescript
// components/ui/Button.tsx
import { ReactNode, ButtonHTMLAttributes } from "react"

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  children: ReactNode
  variant?: "primary" | "secondary" | "outline" | "danger"
  size?: "sm" | "md" | "lg"
  isLoading?: boolean
  isDisabled?: boolean
}

function Button({
  children,
  variant = "primary",
  size = "md",
  isLoading = false,
  isDisabled = false,
  className = "",
  ...props
}: ButtonProps) {
  const baseStyles = "font-medium rounded transition-colors focus-visible:outline-2 focus-visible:outline-offset-2"

  const variantStyles = {
    primary: "bg-blue-600 text-white hover:bg-blue-700 focus-visible:outline-blue-600",
    secondary: "bg-gray-100 text-gray-900 hover:bg-gray-200 focus-visible:outline-gray-400",
    outline: "border border-gray-300 text-gray-900 hover:bg-gray-50 focus-visible:outline-gray-300",
    danger: "bg-red-600 text-white hover:bg-red-700 focus-visible:outline-red-600",
  }

  const sizeStyles = {
    sm: "px-3 py-1.5 text-sm",
    md: "px-4 py-2 text-base",
    lg: "px-6 py-3 text-lg",
  }

  return (
    <button
      className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${
        (isDisabled || isLoading) ? "opacity-50 cursor-not-allowed" : ""
      } ${className}`}
      disabled={isDisabled || isLoading}
      {...props}
    >
      {isLoading ? (
        <span className="inline-flex items-center gap-2">
          <span className="h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent" />
          Loading...
        </span>
      ) : (
        children
      )}
    </button>
  )
}

export { Button, type ButtonProps }
```

### API Client Setup

```typescript
// api/client.ts
import { createRoot } from "react"

interface ApiResponse<T> {
  data?: T
  error?: {
    code: string
    message: string
  }
  meta?: any
}

class ApiClient {
  private baseUrl: string
  private timeout: number = 30000

  constructor(baseUrl: string = import.meta.env.VITE_API_URL || "http://localhost:8000/api/v1") {
    this.baseUrl = baseUrl
  }

  private async request<T>(
    method: string,
    endpoint: string,
    options: RequestInit = {},
  ): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`
    const headers = {
      "Content-Type": "application/json",
      ...options.headers,
    }

    // Add auth token if available
    const token = localStorage.getItem("auth_token")
    if (token) {
      headers["Authorization"] = `Bearer ${token}`
    }

    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), this.timeout)

    try {
      const response = await fetch(url, {
        method,
        headers,
        ...options,
        signal: controller.signal,
      })

      if (!response.ok) {
        const error = await response.json().catch(() => ({ message: response.statusText }))
        throw new Error(error.message || `HTTP ${response.status}`)
      }

      const data: ApiResponse<T> = await response.json()

      if (data.error) {
        throw new Error(data.error.message)
      }

      return data.data as T
    } finally {
      clearTimeout(timeoutId)
    }
  }

  async get<T>(endpoint: string): Promise<T> {
    return this.request<T>("GET", endpoint)
  }

  async post<T>(endpoint: string, body?: any): Promise<T> {
    return this.request<T>("POST", endpoint, {
      body: body ? JSON.stringify(body) : undefined,
    })
  }

  async patch<T>(endpoint: string, body?: any): Promise<T> {
    return this.request<T>("PATCH", endpoint, {
      body: body ? JSON.stringify(body) : undefined,
    })
  }

  async delete<T>(endpoint: string): Promise<T> {
    return this.request<T>("DELETE", endpoint)
  }
}

export const apiClient = new ApiClient()
```

## Tailwind CSS Setup & Best Practices

### Tailwind Configuration

```typescript
// tailwind.config.ts
import type { Config } from "tailwindcss"

export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {
      colors: {
        databricks: "#1F33E7",
        "databricks-dark": "#0C1AA8",
      },
      spacing: {
        "safe": "var(--safe-area-inset-top)",
      },
    },
  },
  plugins: [require("@tailwindcss/forms"), require("@tailwindcss/typography")],
} satisfies Config
```

### Responsive Design (Mobile-First)

```typescript
// ✅ CORRECT - Mobile-first responsive design
function DatasetGrid() {
  return (
    <div className="grid gap-4 grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
      {datasets.map((dataset) => (
        <DatasetCard key={dataset.id} {...dataset} />
      ))}
    </div>
  )
}

// ✅ CORRECT - Responsive text sizes
function PageTitle({ children }: { children: ReactNode }) {
  return (
    <h1 className="text-2xl md:text-3xl lg:text-4xl font-bold text-gray-900">
      {children}
    </h1>
  )
}

// ✅ CORRECT - Responsive spacing
function Container({ children }: { children: ReactNode }) {
  return (
    <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 py-8">
      {children}
    </div>
  )
}
```

### Tailwind Utility Helper

```typescript
// utils/cn.ts
export function cn(...classes: (string | undefined | null | boolean)[]): string {
  return classes
    .filter((cls) => typeof cls === "string")
    .join(" ")
    .trim()
}

// Usage
<div className={cn(
  "p-4 rounded-lg",
  isActive && "bg-blue-500 text-white",
  isDisabled && "opacity-50 cursor-not-allowed",
)} />
```

## State Management Pattern

For simple apps, use React Context + hooks. For complex state, use a library:

```typescript
// contexts/DatasetsContext.tsx
import { createContext, useContext, useState, ReactNode } from "react"

interface Dataset {
  id: string
  name: string
  description: string
}

interface DatasetsContextType {
  datasets: Dataset[]
  selectedDatasetId: string | null
  setSelectedDatasetId: (id: string | null) => void
  addDataset: (dataset: Dataset) => void
}

const DatasetsContext = createContext<DatasetsContextType | undefined>(undefined)

function DatasetsProvider({ children }: { children: ReactNode }) {
  const [datasets, setDatasets] = useState<Dataset[]>([])
  const [selectedDatasetId, setSelectedDatasetId] = useState<string | null>(null)

  const addDataset = (dataset: Dataset) => {
    setDatasets((prev) => [...prev, dataset])
  }

  return (
    <DatasetsContext.Provider
      value={{
        datasets,
        selectedDatasetId,
        setSelectedDatasetId,
        addDataset,
      }}
    >
      {children}
    </DatasetsContext.Provider>
  )
}

function useDatasets(): DatasetsContextType {
  const context = useContext(DatasetsContext)
  if (!context) {
    throw new Error("useDatasets must be used within DatasetsProvider")
  }
  return context
}

export { DatasetsProvider, useDatasets }
```

## Type Safety

### API Response Types

```typescript
// types/api.ts
export interface Dataset {
  id: string
  name: string
  description: string
  catalog: string
  schema: string
  table: string
  rowCount: number
  columnCount: number
  createdAt: string
  updatedAt: string
}

export interface DatasetListResponse {
  data: Dataset[]
  meta: {
    pagination: {
      total: number
      page: number
      pageSize: number
      totalPages: number
    }
  }
}

export interface ErrorResponse {
  error: {
    code: string
    message: string
    details?: Record<string, any>
  }
}
```

## Chart Integration (Recharts)

```typescript
// components/charts/AccessTrendChart.tsx
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
} from "recharts"

interface DataPoint {
  date: string
  accesses: number
}

interface AccessTrendChartProps {
  data: DataPoint[]
  isLoading?: boolean
}

function AccessTrendChart({ data, isLoading = false }: AccessTrendChartProps) {
  if (isLoading) {
    return <div className="h-64 bg-gray-100 animate-pulse rounded-lg" />
  }

  return (
    <div className="w-full h-64">
      <ResponsiveContainer width="100%" height="100%">
        <LineChart data={data} margin={{ top: 5, right: 30, left: 0, bottom: 5 }}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="date" />
          <YAxis />
          <Tooltip />
          <Legend />
          <Line
            type="monotone"
            dataKey="accesses"
            stroke="#1F33E7"
            strokeWidth={2}
            dot={{ fill: "#1F33E7" }}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  )
}

export { AccessTrendChart }
```

## Error Handling & User Feedback

```typescript
// components/ErrorAlert.tsx
interface ErrorAlertProps {
  error: Error | null
  onRetry?: () => void
  onDismiss?: () => void
}

function ErrorAlert({ error, onRetry, onDismiss }: ErrorAlertProps) {
  if (!error) return null

  return (
    <div className="rounded-lg bg-red-50 border border-red-200 p-4">
      <div className="flex items-start gap-3">
        <span className="text-red-600 text-2xl">⚠️</span>
        <div className="flex-1">
          <h3 className="font-semibold text-red-900">Something went wrong</h3>
          <p className="text-sm text-red-700 mt-1">{error.message}</p>
          <div className="flex gap-2 mt-3">
            {onRetry && (
              <button
                onClick={onRetry}
                className="text-sm font-medium text-red-600 hover:text-red-700"
              >
                Try again
              </button>
            )}
            {onDismiss && (
              <button
                onClick={onDismiss}
                className="text-sm font-medium text-red-600 hover:text-red-700"
              >
                Dismiss
              </button>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

export { ErrorAlert }
```

## TypeScript Best Practices

- **Avoid `any`**: Use `unknown` with type guards instead
- **Use `Pick`/`Omit`**: Extract subsets of types
- **Use `Readonly`**: Mark immutable data
- **Use discriminated unions**: For variant types

```typescript
// ✅ CORRECT - discriminated union for API states
type DatasetState =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: Dataset[] }
  | { status: "error"; error: Error }

function DatasetList() {
  const [state, setState] = useState<DatasetState>({ status: "idle" })

  switch (state.status) {
    case "idle":
      return <div>Click to load datasets</div>
    case "loading":
      return <LoadingSpinner />
    case "success":
      return <div>{state.data.map((d) => <DatasetCard key={d.id} {...d} />)}</div>
    case "error":
      return <ErrorAlert error={state.error} />
  }
}
```

## Naming Conventions

- **Files**: PascalCase for components (`DatasetCard.tsx`), camelCase for utils (`formatDate.ts`)
- **Variables/Functions**: camelCase (`isLoading`, `handleClick`)
- **Interfaces/Types**: PascalCase (`DatasetCardProps`, `Dataset`)
- **Constants**: UPPERCASE (`MAX_PAGE_SIZE = 100`)
- **Boolean variables**: Prefix with `is`, `has`, `can`, `should` (`isOpen`, `hasError`)

## Performance Optimization

```typescript
// Use React.memo for expensive components
const DatasetCard = React.memo(function DatasetCard(props: DatasetCardProps) {
  return (
    <div className="...">
      {/* component content */}
    </div>
  )
})

// Use useCallback for stable function references
function DatasetList() {
  const handleSelect = useCallback((id: string) => {
    setSelectedId(id)
  }, [])

  return <DatasetCard onSelect={handleSelect} />
}
```

## Environment Variables

```typescript
// src/config.ts
export const config = {
  API_URL: import.meta.env.VITE_API_URL || "http://localhost:8000/api/v1",
  DATABRICKS_HOST: import.meta.env.VITE_DATABRICKS_HOST || "",
  LOG_LEVEL: (import.meta.env.VITE_LOG_LEVEL || "info") as "debug" | "info" | "warn" | "error",
} as const
```

`.env.local`:
```
VITE_API_URL=http://localhost:8000/api/v1
VITE_LOG_LEVEL=debug
```